/**
 * Marcos Nuez - 761319@unizar.es
 * Alvaro Echavarri - 737400@unizar.es
 * v2 - 2021/04/13
 */

options
{
  static = true;
  ignore_case = true;
  
}

PARSER_BEGIN(minilengcompiler) 

package analizador;
import java.io.*;
import lib.aviso.*;
import lib.semantico.*; 
import java.util.ArrayList;
import lib.semantico.Simbolo.*;
import lib.semantico.Elemento.*;
 
public class minilengcompiler {
  
  static boolean errorSintactico = false;
  static boolean errorSemantico = false;
  static TablaSimbolos tabla_simbolos = new TablaSimbolos();
  static int nivel = 0;
  static int direccion=3;
  static int ejecucion_correcta=1;
  
	 public static void main(String args []) throws ParseException {
	   tabla_simbolos.inicializar_tabla();
	    if (args.length != 0 ) {
			File tmp = new File(args[0]);
			String file = tmp.getAbsolutePath();
			try {
				minilengcompiler parser = new minilengcompiler(new FileInputStream(file));
			}  
			catch (FileNotFoundException e) {
				System.out.printf("No existe el fichero: "+ file + "\n"); 
				System.exit(1);
			}
      	}
      	else {
      	    System.out.printf("Leyendo de la entrada estandar..." + "\n");
			minilengcompiler parser = new minilengcompiler(System.in);
        }    	
   		try {  
		    minilengcompiler.programa();

		    if ( errorSintactico ) {
				System.out.println("Hay uno o más errores sintácticos");
				System.exit(1);
		    }
		    
		    if ( errorSemantico ) {
				System.out.println("Hay uno o más errores semánticos");
				System.exit(1);
		    }
		     
		    System.out.println("Analizado correctamente");	
		}
		catch(TokenMgrError e) {  
		     // ERRORES LEXICOS
		     try {
				String simbolo = String.valueOf(minilengcompilerTokenManager.input_stream.readChar());
		        String fil = String.valueOf(minilengcompilerTokenManager.input_stream.getEndLine());
		        String col = String.valueOf(minilengcompilerTokenManager.input_stream.getEndColumn());
		     
		        System.err.println("ERROR LÉXICO (<" + fil + ", " + col + ">): símbolo no reconocido: <" + simbolo + ">");
		        ejecucion_correcta=0;
		        return;
		     }  
		     catch (Exception ex) { }
		}    
 	 }
 	 
 	 private static void error_sintactico(ParseException e, String mensaje) {
    	// ERRORES SINTACTICOS
    	Token ultimoLeido = minilengcompiler.getNextToken();
    	int fil = ultimoLeido.beginLine;
    	int col = ultimoLeido.beginColumn;
    	String current = ultimoLeido.image;
    
    	System.out.println("ERROR SINTÁCTICO (<" + fil  + ", " + col + ">): Token obtenido -> " + current + " -> " + mensaje );
    	if ( !errorSintactico ) {
			errorSintactico = true;
   		}
   		ejecucion_correcta=0;
  	}

  	private static void error_semantico(String name, int f, int col, Exception except) {
  		// ERRORES SEMÁNTICOS
  		if ( !errorSemantico ) {
			errorSemantico = true;
   		}
   		
  		if (except instanceof SimboloNoEncontradoException) {
			System.out.println("ERROR SEMÁNTICO: <No se ha encontrado el símbolo llamado: " + name + "> en (<" + f  + ", " + col + ">)");
	    }
		else if (except instanceof SimboloYaDeclaradoException) {
			System.out.println("ERROR SEMÁNTICO: <Ya ha sido declarado el símbolo llamado: " + name + "> en (<" + f  + ", " + col + ">)");
		}else if (except instanceof OutOfBoundsIntExcepction) {
			System.out.println("ERROR SEMÁNTICO: <Entero fuera de rango dentro de: " + name + "> en (<" + f  + ", " + col + ">)");
		}else if (except instanceof WrongExpresionException) {
			System.out.println("ERROR SEMÁNTICO: <Expresion no valida dentro de: " + name + "> en (<" + f  + ", " + col + ">)");
		}else if (except instanceof DivZeroException) {
			System.out.println("ERROR SEMÁNTICO: <Division por 0 encontrada en: " + name + "> en (<" + f  + ", " + col + ">)");
		}
		ejecucion_correcta=0;
 	}  
}

PARSER_END(minilengcompiler)

< DEFAULT >SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "%" : COMLINE
| "%%" : COMBLOCK
}

< COMLINE >SKIP :
{
  "\n" : DEFAULT
}

< COMBLOCK >SKIP :
{
  "%%" : DEFAULT
}


< COMLINE >MORE :
{
  < ~[ ] >
}

< COMBLOCK >MORE :
{
  < ~[ ] >
}

TOKEN : /* CONTROLES DE FLUJO */
{
  < tPROGRAMA : "programa" >
| < tACCION : "accion" >
| < tENT : "ent" >
| < tSI_NO : "si_no" >
| < tPRINCIPIO : "principio" >  
| < tFIN : "fin" >
| < tMQ : "mq" >
| < tFMQ : "fmq" >
| < tSI : "si" >
| < tFSI : "fsi" >
}

TOKEN : /* FUNCIONES */
{
  < tMOD : "mod" >
| < tESCRIBIR : "escribir" >
| < tLEER : "leer" >  
| < tENTACAR : "entacar" >
| < tCARAENT : "caraent" >
}
  
TOKEN : /* OPERADORES */
{
  < tSUMA : "+" >
| < tRESTA : "-" >
| < tMULL : "*" >
| < tDIV : "/" >
| < tDIV1 : "div" >       
| < tMAYOR : ">" >
| < tMENOR : "<" >
| < tIGUAL : "=" >
| < tOAS : ":=" >
| < tMAI : ">=" >
| < tMEI : "<=" >
| < tNI : "<>" >
| < tAND : "and" >             
| < tOR : "or" >
| < tNOT : "not" >                                   
}

TOKEN : /* TIPOS DE DATOS */
{
  < tENTERO : "entero" >
| < tBOOLEANO : "booleano" >
| < tCARACTER : "caracter" >
| < tVAL : "val" >
| < tREF : "ref" >
| < tTRUE : "true" >
| < tFALSE : "false" >      
}

TOKEN : /* AGRUPACIONES */
{
  <  tLLAVE_IZQ : "{" >
| <  tLLAVE_DCHA : "}" >
| <  tPA : "(" >
| <  tPC : ")" >   
}

TOKEN : /* VALORES */
{
  < #DIGITO : ["0"-"9"] >
| < #LETRA : ["a"-"z","_","0"-"9"] >
| < #BOOLEAN : "true" | "false" >
| < #LETRAID_INICIAL : ["a"-"z","_"] >
| < #LETRAID_FINAL : ["a"-"z","0"-"9"] >
| < #CARACTER : "\""~["\""] "\"" >
| < #CADENA : "\""(~["\""])+ "\"" >
| < #CADENA_VACIA : "\"""\"" >

| < tVALOR_ENTERO : (< DIGITO >)+ >
| < tVALOR_CARACTER : ("-")?(< CARACTER >) >
| < tVALOR_CADENA : ("-")?(< CADENA >) >
| < tVALOR_CADENA_VACIA : ("-")?(< CADENA_VACIA >) >
| < tVALOR_BOOLEANO : ("-")?(< BOOLEAN >) >
| <  tIDENTIFICADOR : (< LETRAID_INICIAL >)(< LETRA >)*(< LETRAID_FINAL >) | (< LETRAID_INICIAL >) >
}

TOKEN : /* FINES DE SENTENCIA */
{
  <  tFIN_SENTENCIA : ";" >
| <  tCOMA : "," >
}


void programa():
{
  Token p=null;
}
{
  try { 
  	< tPROGRAMA > p=< tIDENTIFICADOR >
  		{
  		  if(p!=null){
			tabla_simbolos.introducir_programa(p.image,0);
			tabla_simbolos.imprimirTabla();
  	 	  }
  	  	}
  	   < tFIN_SENTENCIA > (declaracion_variables()) (declaracion_acciones())
 	 (bloque_sentencias())*
 	 {
 	   if(ejecucion_correcta==1) {
			tabla_simbolos.eliminar_variables(nivel);
			tabla_simbolos.eliminar_acciones(nivel);
			tabla_simbolos.eliminar_programa();
			tabla_simbolos.imprimirTabla();
 	   }
 	 }
  }catch(ParseException e) {
		error_sintactico(e,"Sintaxis de programa incorrecta");
	}
}

void sentencia():
{
}
{
try { 
  	(leer()) < tFIN_SENTENCIA >
 |  (escribir()) < tFIN_SENTENCIA >
 |  < tIDENTIFICADOR > (asignacion_invocacion_accion()) < tFIN_SENTENCIA >
 |	(seleccion()) 
 |	(mientras_que())
 | 	(si())
 
}catch(ParseException e) {
	error_sintactico(e,"Sintaxis de sentencia incorrecta");
}
}

void asignacion_invocacion_accion():
{
}
{
  try { 
  asignacion()|invocacion_accion()
}catch(ParseException e) {
	error_sintactico(e,"No se encuentra asignacion o invocacion a accion");
}
}

void asignacion():
{
}
{
  try { 
  < tOAS > expresion()
}catch(ParseException e) {
	error_sintactico(e,"Sintaxis de asignacion incorrecta");
}
}

void invocacion_accion():
{
}
{
  try {
    (argumentos())?
}catch(ParseException e) {
	error_sintactico(e,"Sintaxis de invocacion a accion incorrecta");
}
}

void declaracion_variables():
{
}
{
  try { 
  	( declaracion() ";" )*
 }catch(ParseException e) {
	error_sintactico(e,"Declaracion de variables incorrecta");
}
}

void declaracion():
{
  Tipo_variable tipo = null;
  ArrayList<Token > tokens = null;
}
{
  try { 
  	tipo=tipo_variables() tokens=identificadores()
  	{
		for(int i=0;i<tokens.size();i++) {
		  try { 
			tabla_simbolos.introducir_variable(tokens.get(i).image,tipo,nivel,direccion);
			direccion=direccion+1;
			tabla_simbolos.imprimirTabla();
		  } catch(SimboloYaDeclaradoException e) {
		      token = tokens.get(i);
			  error_semantico(token.image, token.beginLine, token.beginColumn, e);
		    }	
  	  	}  
  	}
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis incorrecta");
}
}

Tipo_variable tipo_variables():
{
  Tipo_variable tipo=null;
}
{
  try { 
  	< tENTERO > {tipo=Tipo_variable.ENTERO; }
  	| < tCARACTER > {tipo=Tipo_variable.CHAR; }
  	| < tBOOLEANO > {tipo=Tipo_variable.BOOLEANO; }
 }catch(ParseException e) {
	error_sintactico(e,"No se ha encontrado tipo de variable");
}
{return tipo;}
}

ArrayList<Token> identificadores():
{
  Token t=null;
  ArrayList<Token> tokens = new ArrayList<Token>();
}
{
  try { 
  	t=< tIDENTIFICADOR >
  		{
  		  if(t!=null){
				tokens.add(t);
  	 		}
  	  	} ( "," t=< tIDENTIFICADOR >
  		{
  		  if(t!=null){
			tokens.add(t);
  	 		}
  	  	} )*
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis en definicion de identificadores incorrecta");
}
{return tokens;}
}

void declaracion_acciones():
{
}
{
  try { 
  	( declaracion_accion() )*
 }catch(ParseException e) {
	error_sintactico(e,"Declaracion de acciones incorrecta");
}
}

void declaracion_accion():
{
  int direccion_anterior=direccion;
}
{
  try {
     
  	cabecera_accion() declaracion_variables() declaracion_acciones() bloque_sentencias()
  	{ tabla_simbolos.eliminar_variables(nivel);
  	  tabla_simbolos.eliminar_parametros(nivel);
  	  direccion=direccion_anterior;
  	  tabla_simbolos.imprimirTabla();
  	  nivel=nivel-1; }
 }catch(ParseException e) {
	error_sintactico(e,"Estructura de accion incorrecta");
}
}

void cabecera_accion():
{
  Token t=null;
}
{
  try { 
  	< tACCION > t=< tIDENTIFICADOR > {  
  		if(t != null){
  		  try {
			tabla_simbolos.introducir_accion(t.image,nivel,direccion);
			direccion = direccion+1;
			tabla_simbolos.imprimirTabla();
			nivel=nivel+1;
  		  } catch(SimboloYaDeclaradoException e) {
			  error_semantico(t.image, t.beginLine, t.beginColumn, e);
  		    }
  	 	}
  	}(parametros_formales())?< tFIN_SENTENCIA >
  	
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis en definicion de accion incorrecta");
}
}

void parametros_formales():
{
}
{
  try { 
  < tPA >(parametros() (< tFIN_SENTENCIA > parametros())*)?< tPC >
}catch(ParseException e) {
	error_sintactico(e,"Estructura de parametros de accion incorrecta");
}
}

void parametros():
{
  ArrayList<Token > tokens=null;
  Tipo_variable tipo=null;
  Clase_parametro clase=null;
}
{
  try { 
  	clase=clase_parametros() tipo=tipo_variables() tokens=identificadores()
  	{
  	  for(int i = 0; i < tokens.size(); i++) {
  	    try { 
		  tabla_simbolos.introducir_parametro(tokens.get(i).image,tipo,clase,nivel,direccion);
		  direccion = direccion+1;
		  tabla_simbolos.imprimirTabla();
		} catch(SimboloYaDeclaradoException e) {
			token = tokens.get(i);
			error_semantico(token.image, token.beginLine, token.beginColumn, e);
		  }	
  	  }
  	}
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de parametros incorrecta");
}
}

Clase_parametro clase_parametros():
{
  Clase_parametro clase=null;
}
{
  try { 
  	< tVAL >{clase=Clase_parametro.VAL; }
  	| < tREF >{clase=Clase_parametro.REF; }
 }catch(ParseException e) {
	error_sintactico(e,"Tipo de parametro no encontrado");
}
{return clase;}
}

void bloque_sentencias():
{
}
{
  try { 
  	< tPRINCIPIO > lista_sentencias() < tFIN >
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de bloque de sentencias incorrecta");
}
}

void lista_sentencias():
{
}
{
  try {
  	(sentencia())*
 }catch(ParseException e) {
	error_sintactico(e,"Estructura de sentencias incorrecta");
}
}

void leer():
{
}
{
  try { 
  	< tLEER > < tPA > identificadores() < tPC >
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de leer incorrecta");
}
}

void escribir():
{
}
{
  try { 
  	< tESCRIBIR > < tPA > lista_escribibles() < tPC >
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de escribir incorrecta");
}
}

void caraent():
{
}
{
  try { 
  < tCARAENT ><tPA >(expresion())<tPC >
}catch(ParseException e) {
	error_sintactico(e,"Sintaxis de caraent incorrecta");
}
}

void entacar():
{
}
{
  try { 
  < tENTACAR ><tPA >(expresion())<tPC >
}catch(ParseException e) {
	error_sintactico(e,"Sintaxis de entacar incorrecta");
}
}

void lista_escribibles():
{
}
{
  try { 
  	( expresion() ) ( < tCOMA > (expresion() ) )*
}catch(ParseException e) {
	error_sintactico(e,"Estructura de escribir incorrecta ");
}
}

void mientras_que():
{
}
{
  try { 
  	< tMQ > expresion() lista_sentencias() < tFMQ >
 }catch(ParseException e) {
	error_sintactico(e,"Estructura de mientras que incorrecta");
}
}

void si():
{
}
{
  try { 
  	< tSI > expresion() < tENT > lista_sentencias() (< tSI_NO > lista_sentencias())* < tFSI >

 }catch(ParseException e) {
	error_sintactico(e,"Estructura de si incorrecta");
}
}

void argumentos():
{
}
{
  try { 
  	< tPA > ( lista_expresiones() )? < tPC >
 }catch(ParseException e) {
	error_sintactico(e,"Estructura de lista de argumentos incorrecta");
}
}

void lista_expresiones():
{
}
{
  try { 
  	expresion()(","expresion())*
 }catch(ParseException e) {
	error_sintactico(e,"Estructura de lista de expresiones incorrecta");
}
}

void seleccion():
{
}
{
  try { 
  	< tPRINCIPIO > < tIDENTIFICADOR > < tLLAVE_IZQ > (sentencia())* < tLLAVE_DCHA >
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de seleccion incorrecta");
}
}

Elemento expresion():
{
  Elemento el=new Elemento();
}
{
  try {
   expresion2() (operador_relacional() expresion2())*
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de expresion incorrecta");
}
	{return el;}
}

Elemento expresion2():
{
  op o1=null;
  op o2=null;
  Token t=null;
  Elemento el=new Elemento();
  Elemento el1=new Elemento();
  Elemento el2=new Elemento();
}
{
  try {
    (o1=operador_aditivo())? el1=expresion3() ((o2=operador_aditivo()|t=< tOR >) el2=expresion3(){
     if(el1.getTipo()!=Tipo_variable.DESCONOCIDO && el2.getTipo()!=Tipo_variable.DESCONOCIDO) { 
     	if(o2!=null) {
       		if(el1.getTipo()==Tipo_variable.ENTERO && el2.getTipo()==Tipo_variable.ENTERO) {
         		if(el1.getEntero()!=null && el2.getEntero()!=null) {
					el.setTipo(Tipo_variable.ENTERO);
					switch (o2) {
						case SUMA:
							el.setEntero(el1.getEntero()+el2.getEntero());
							break;
						case RESTA:
							el.setEntero(el1.getEntero()-el2.getEntero());
					}
         		}
        	}else {
				error_semantico(t.image, t.beginLine, t.beginColumn, new WrongExpresionException());
        	}
     	}else if(t!=null) {
			if(el1.getTipo()==Tipo_variable.BOOLEANO && el2.getTipo()==Tipo_variable.BOOLEANO) {
				el.setTipo(Tipo_variable.BOOLEANO);
				if(el1.getBool()!=null && el2.getBool()!=null) {
					el.setBool(el1.getBool() || el2.getBool());
				}
			}else {
				error_semantico(t.image, t.beginLine, t.beginColumn, new WrongExpresionException());
			}
    	}
   	}else if(el1.getTipo()==Tipo_variable.DESCONOCIDO && el2.getTipo()!=Tipo_variable.DESCONOCIDO){
		el=el2;
   	}else if(el1.getTipo()!=Tipo_variable.DESCONOCIDO && el2.getTipo()==Tipo_variable.DESCONOCIDO){
		el=el1;
   	}else {
   	  el.setTipo(Tipo_variable.DESCONOCIDO);
   	}
  })*
    
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de expresion incorrecta");
}
	{
	  //if(o1.op==RESTA) {
		//return -el;
	  //}
	return el;
	}
}

Elemento expresion3():
{
  op o=null;
  Token t=null;
  Elemento el=new Elemento();
  Elemento el1=new Elemento();
  Elemento el2=new Elemento();
}
{
  try {
   el1=factor()( (o=operador_multiplicativo()|t=< tAND >) el2=factor() {
     if(el1.getTipo()!=Tipo_variable.DESCONOCIDO && el2.getTipo()!=Tipo_variable.DESCONOCIDO) { 
     	if(o!=null) {
       		if(el1.getTipo()==Tipo_variable.ENTERO && el2.getTipo()==Tipo_variable.ENTERO) {
         		if(el1.getEntero()!=null && el2.getEntero()!=null) {
					el.setTipo(Tipo_variable.ENTERO);
					switch (o) {
						case MULL:
				
							el.setEntero(el1.getEntero()*el2.getEntero());
							break;
						case DIV:
							if(el2.getEntero()==0) {
								error_semantico(t.image, t.beginLine, t.beginColumn, new DivZeroException());
							}else { 
								el.setEntero(el1.getEntero()/el2.getEntero());
							}
							break;
						case DIV1:
							if(el2.getEntero()==0) {
								error_semantico(t.image, t.beginLine, t.beginColumn, new DivZeroException());
							}else { 
								el.setEntero(el1.getEntero()/el2.getEntero());
							}
							break;
						case MOD:
							if(el2.getEntero()==0) {
								error_semantico(t.image, t.beginLine, t.beginColumn, new DivZeroException());
							}else {
							el.setEntero(el1.getEntero()%el2.getEntero());
							}
					}
         		}
        	}else {
				error_semantico(t.image, t.beginLine, t.beginColumn, new WrongExpresionException());
			}
     	}else if(t!=null) {
			if(el1.getTipo()==Tipo_variable.BOOLEANO && el2.getTipo()==Tipo_variable.BOOLEANO) {
				el.setTipo(Tipo_variable.BOOLEANO);
				if(el1.getBool()!=null && el2.getBool()!=null) {
					el.setBool(el1.getBool() && el2.getBool());
				}
			}else {
				error_semantico(t.image, t.beginLine, t.beginColumn, new WrongExpresionException());
			}
    	}
   	}else if(el1.getTipo()==Tipo_variable.DESCONOCIDO && el2.getTipo()!=Tipo_variable.DESCONOCIDO){
		el=el2;
   	}else if(el1.getTipo()!=Tipo_variable.DESCONOCIDO && el2.getTipo()==Tipo_variable.DESCONOCIDO){
		el=el1;
   	}else {
   	  el.setTipo(Tipo_variable.DESCONOCIDO);
   	}
  })*
   
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de expresion incorrecta");
}
	{return el;}
}

op operador_relacional():
{
} 
{
  try { 
	 < tMENOR >	{return op.MENOR;}
	| < tMAYOR >{return op.MAYOR;}
	| < tMEI >	{return op.MEI;}
	| < tMAI >	{return op.MAI;}
	| < tIGUAL >{return op.IGUAL;}
	| < tNI >	{return op.NI;}
	
}catch(ParseException e) {
	error_sintactico(e,"Operador relacional no encontrado");
}

}

op operador_aditivo():
{
}
{
  try { 
  < tRESTA >	{return op.RESTA;}
	| < tSUMA >	{return op.SUMA;}
}catch(ParseException e) {
	error_sintactico(e,"Operador aditivo no encontrado");
}
}

op operador_multiplicativo():
{
} 
{
  try { 
  < tMULL >		{return op.MULL;}
	| < tDIV >	{return op.DIV;}
	| < tDIV1 >	{return op.DIV1;}
	| < tMOD >	{return op.MOD;}
}catch(ParseException e) {
	error_sintactico(e,"Operador multiplicativo no encontrado");
}
}

Elemento factor():
{
  Token t=null;
  Elemento el=new Elemento();
}
{
  try { 
  (t=< tNOT >)? el=factor2() {
	if(t!=null ) {
		if(el.getTipo()==Tipo_variable.DESCONOCIDO || el.getTipo()==Tipo_variable.BOOLEANO) {
			if(el.getBool()!=null) {
				el.setBool(!el.getBool());
			}
		}else {
			error_semantico(t.image, t.beginLine, t.beginColumn, new WrongExpresionException());
		} 
	}
  }
}catch(ParseException e) {
	error_sintactico(e,"Factor no encontrado");
}
	{return el;}
}

Elemento factor2():
{
  Token t=null;
  Simbolo s=null;
  Elemento e=new Elemento();
}
{
  try {
     
   < tPA > e=expresion() < tPC >
	| t=< tENTACAR > < tPA > e=expresion() {
	  	Character c=null;
		if(e.getTipo()==Tipo_variable.ENTERO && e.getEntero()!=null) {
		  
			if(e.getEntero() <0 || e.getEntero() >255 ) {
			  error_semantico(t.image, t.beginLine, t.beginColumn, new OutOfBoundsIntExcepction());
			}else {
			  c=(char)e.getEntero().intValue();
			}
		}else {
		  error_semantico(t.image, t.beginLine, t.beginColumn, new WrongExpresionException());
		} 
		e=new Elemento();
		e.setTipo(Tipo_variable.CHAR);
		e.setCaracter(c);

	} < tPC >
	| t=< tCARAENT > < tPA > e=expresion(){
	  	Integer en=null;
		if(e.getTipo()==Tipo_variable.CHAR && e.getCaracter()!=null) {
			en=(int)e.getCaracter().charValue();
		}else {
		  error_semantico(t.image, t.beginLine, t.beginColumn, new WrongExpresionException());
		} 
		e=new Elemento();
		e.setTipo(Tipo_variable.ENTERO);
		e.setEntero(en);

	} < tPC >
	| t=< tIDENTIFICADOR > {
	   try {
	     	s=tabla_simbolos.buscar_simbolo(t.image);
	     	if(s.ES_PARAMETRO()) {
				e.setPara(s.getParametro());
	     	}
	     	
	     }catch(SimboloNoEncontradoException es) {
	       
			error_semantico(t.image, t.beginLine, t.beginColumn, es);
			try {
				s=tabla_simbolos.introducir_variable(t.image, Tipo_variable.DESCONOCIDO,nivel, direccion);
				direccion++;
				e.setTipo(Tipo_variable.DESCONOCIDO);
				
				if(s.ES_PARAMETRO()) {
					e.setPara(s.getParametro());
	     		}
			}catch(SimboloYaDeclaradoException ex) {}
			
		}
	} 
	| t=< tVALOR_CARACTER >{
	  
		e.setTipo(Tipo_variable.CHAR);
		e.setCaracter(t.image.charAt(1));
		
	} 
	| t=< tVALOR_CADENA >{
	  
		e.setTipo(Tipo_variable.CADENA);
		e.setCadena(t.image);
		
	}
	| t=< tVALOR_CADENA_VACIA >{
	  
		e.setTipo(Tipo_variable.CADENA);
		e.setCadena(t.image);
		
	}
	| t=< tVALOR_ENTERO >{
	  
		e.setTipo(Tipo_variable.ENTERO);
		e.setEntero(Integer.parseInt(t.image));
		
	}
	| t=< tTRUE >{
	  
		e.setTipo(Tipo_variable.BOOLEANO);
		e.setBool(true);
		
	}
	| t=< tFALSE >{
	  
		e.setTipo(Tipo_variable.BOOLEANO);
		e.setBool(false);
		
	}

	
}catch(ParseException esc) {
	error_sintactico(esc,"Sintaxis de factor incorrecta");
}
{return e;}
}