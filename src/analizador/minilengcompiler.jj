/**
 * Marcos Nuez - 761319@unizar.es
 * Alvaro Echavarri - 737400@unizar.es
 * v2 - 2021/04/13
 */

options
{
  static = true;
  ignore_case = true;
  
}

PARSER_BEGIN(minilengcompiler) 

package analizador;
import java.io.*;
import lib.aviso.*;
import lib.semantico.*;
import java.util.ArrayList;
import lib.semantico.Simbolo.*;


public class minilengcompiler {
  
  static boolean errorSintactico = false;
  static TablaSimbolos tabla_simbolos = new TablaSimbolos();
  static int nivel = 0;
  static int direccion=3;
  static int ejecucion_correcta=1;
  
	 public static void main(String args []) throws ParseException {
	   tabla_simbolos.inicializar_tabla();
	    if (args.length != 0 ) {
			File tmp = new File(args[0]);
			String file = tmp.getAbsolutePath();
			try {
				minilengcompiler parser = new minilengcompiler(new FileInputStream(file));
			}  
			catch (FileNotFoundException e) {
				System.out.printf("No existe el fichero: "+ file + "\n"); 
				System.exit(1);
			}
      	}
      	else {
      	    System.out.printf("Leyendo de la entrada estandar..." + "\n");
			minilengcompiler parser = new minilengcompiler(System.in);
        }    	
   		try {  
		    minilengcompiler.programa();

		    if ( errorSintactico ) {
				System.out.println("Hay uno o más errores sintácticos");
				System.exit(1);
		    }
		     
		    System.out.println("Analizado correctamente");	
		}
		catch(TokenMgrError e) {  
		     // ERRORES LEXICOS
		     try {
				String simbolo = String.valueOf(minilengcompilerTokenManager.input_stream.readChar());
		        String fil = String.valueOf(minilengcompilerTokenManager.input_stream.getEndLine());
		        String col = String.valueOf(minilengcompilerTokenManager.input_stream.getEndColumn());
		     
		        System.err.println("ERROR LÉXICO (<" + fil + ", " + col + ">): símbolo no reconocido: <" + simbolo + ">");
		        ejecucion_correcta=0;
		        return;
		     }  
		     catch (Exception ex) { }
		}    
 	 }
 	 
 	 private static void error_sintactico(ParseException e, String mensaje) {
    	// ERRORES SINTACTICOS
    	Token ultimoLeido = minilengcompiler.getNextToken();
    	int fil = ultimoLeido.beginLine;
    	int col = ultimoLeido.beginColumn;
    	String current = ultimoLeido.image;
    
    	System.out.println("ERROR SINTÁCTICO (<" + fil  + ", " + col + ">): Token obtenido -> " + current + " -> " + mensaje );
    	if ( !errorSintactico ) {
			errorSintactico = true;
   		}
   		ejecucion_correcta=0;
  	}

  	private static void error_semantico(String name, int f, int col, Exception except) {
  		// ERRORES SEMÁNTICOS
  		if (except instanceof SimboloNoEncontradoException) {
			System.out.println("ERROR SEMÁNTICO: <No se ha encontrado el símbolo llamado: " + name + "> en (<" + f  + ", " + col + ">)");
	    }
		else if (except instanceof SimboloYaDeclaradoException) {
			System.out.println("ERROR SEMÁNTICO: <Ya ha sido declarado el símbolo llamado: " + name + "> en (<" + f  + ", " + col + ">)");
		}
		ejecucion_correcta=0;
 	}  
}

PARSER_END(minilengcompiler)

< DEFAULT >SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "%" : COMLINE
| "%%" : COMBLOCK
}

< COMLINE >SKIP :
{
  "\n" : DEFAULT
}

< COMBLOCK >SKIP :
{
  "%%" : DEFAULT
}


< COMLINE >MORE :
{
  < ~[ ] >
}

< COMBLOCK >MORE :
{
  < ~[ ] >
}

TOKEN : /* CONTROLES DE FLUJO */
{
  < tPROGRAMA : "programa" >
| < tACCION : "accion" >
| < tENT : "ent" >
| < tSI_NO : "si_no" >
| < tPRINCIPIO : "principio" >  
| < tFIN : "fin" >
| < tMQ : "mq" >
| < tFMQ : "fmq" >
| < tSI : "si" >
| < tFSI : "fsi" >
}

TOKEN : /* FUNCIONES */
{
  < tMOD : "mod" >
| < tESCRIBIR : "escribir" >
| < tLEER : "leer" >  
| < tENTACAR : "entacar" >
| < tCARAENT : "caraent" >
}
  
TOKEN : /* OPERADORES */
{
  < tSUMA : "+" >
| < tRESTA : "-" >
| < tMULL : "*" >
| < tDIV : "/" >
| < tDIV1 : "div" >       
| < tMAYOR : ">" >
| < tMENOR : "<" >
| < tIGUAL : "=" >
| < tOAS : ":=" >
| < tMAI : ">=" >
| < tMEI : "<=" >
| < tNI : "<>" >
| < tAND : "and" >             
| < tOR : "or" >
| < tNOT : "not" >                                   
}

TOKEN : /* TIPOS DE DATOS */
{
  < tENTERO : "entero" >
| < tBOOLEANO : "booleano" >
| < tCARACTER : "caracter" >
| < tVAL : "val" >
| < tREF : "ref" >
| < tTRUE : "true" >
| < tFALSE : "false" >      
}

TOKEN : /* AGRUPACIONES */
{
  <  tLLAVE_IZQ : "{" >
| <  tLLAVE_DCHA : "}" >
| <  tPA : "(" >
| <  tPC : ")" >   
}

TOKEN : /* VALORES */
{
  < #DIGITO : ["0"-"9"] >
| < #LETRA : ["a"-"z","_","0"-"9"] >
| < #BOOLEAN : "true" | "false" >
| < #LETRAID_INICIAL : ["a"-"z","_"] >
| < #LETRAID_FINAL : ["a"-"z","0"-"9"] >
| < #CARACTER : "\""~["\""] "\"" >
| < #CADENA : "\""(~["\""])+ "\"" >
| < #CADENA_VACIA : "\"""\"" >

| < tVALOR_ENTERO : (< DIGITO >)+ >
| < tVALOR_CARACTER : ("-")?(< CARACTER >) >
| < tVALOR_CADENA : ("-")?(< CADENA >) >
| < tVALOR_CADENA_VACIA : ("-")?(< CADENA_VACIA >) >
| < tVALOR_BOOLEANO : ("-")?(< BOOLEAN >) >
| <  tIDENTIFICADOR : (< LETRAID_INICIAL >)(< LETRA >)*(< LETRAID_FINAL >) | (< LETRAID_INICIAL >) >
}

TOKEN : /* FINES DE SENTENCIA */
{
  <  tFIN_SENTENCIA : ";" >
| <  tCOMA : "," >
}


void programa():
{
  Token p=null;
}
{
  try { 
  	< tPROGRAMA > p=< tIDENTIFICADOR >
  		{
  		  if(p!=null){
			tabla_simbolos.introducir_programa(p.image,0);
			tabla_simbolos.imprimirTabla();
  	 	  }
  	  	}
  	   < tFIN_SENTENCIA > (declaracion_variables()) (declaracion_acciones())
 	 (bloque_sentencias())*
 	 {
 	   if(ejecucion_correcta==1) {
			tabla_simbolos.eliminar_variables(nivel);
			tabla_simbolos.eliminar_acciones(nivel);
			tabla_simbolos.eliminar_programa();
			tabla_simbolos.imprimirTabla();
 	   }
 	 }
  }catch(ParseException e) {
		error_sintactico(e,"Sintaxis de programa incorrecta");
	}
}

void sentencia():
{
}
{
try { 
  	(leer()) < tFIN_SENTENCIA >
 |  (escribir()) < tFIN_SENTENCIA >
 |  < tIDENTIFICADOR > (asignacion_invocacion_accion()) < tFIN_SENTENCIA >
 |	(seleccion()) 
 |	(mientras_que())
 | 	(si())
 
}catch(ParseException e) {
	error_sintactico(e,"Sintaxis de sentencia incorrecta");
}
}

void asignacion_invocacion_accion():
{
}
{
  try { 
  asignacion()|invocacion_accion()
}catch(ParseException e) {
	error_sintactico(e,"No se encuentra asignacion o invocacion a accion");
}
}

void asignacion():
{
}
{
  try { 
  < tOAS > expresion()
}catch(ParseException e) {
	error_sintactico(e,"Sintaxis de asignacion incorrecta");
}
}

void invocacion_accion():
{
}
{
  try {
    (argumentos())?
}catch(ParseException e) {
	error_sintactico(e,"Sintaxis de invocacion a accion incorrecta");
}
}

void declaracion_variables():
{
}
{
  try { 
  	( declaracion() ";" )*
 }catch(ParseException e) {
	error_sintactico(e,"Declaracion de variables incorrecta");
}
}

void declaracion():
{
  Tipo_variable tipo = null;
  ArrayList<Token > tokens = null;
}
{
  try { 
  	tipo=tipo_variables() tokens=identificadores()
  	{
		for(int i=0;i<tokens.size();i++) {
		  try { 
			tabla_simbolos.introducir_variable(tokens.get(i).image,tipo,nivel,direccion);
			direccion=direccion+1;
			tabla_simbolos.imprimirTabla();
		  } catch(SimboloYaDeclaradoException e) {
		      token = tokens.get(i);
			  error_semantico(token.image, token.beginLine, token.beginColumn, e);
		    }	
  	  	}  
  	}
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis incorrecta");
}
}

Tipo_variable tipo_variables():
{
  Tipo_variable tipo=null;
}
{
  try { 
  	< tENTERO > {tipo=Tipo_variable.ENTERO; }
  	| < tCARACTER > {tipo=Tipo_variable.CHAR; }
  	| < tBOOLEANO > {tipo=Tipo_variable.BOOLEANO; }
 }catch(ParseException e) {
	error_sintactico(e,"No se ha encontrado tipo de variable");
}
{return tipo;}
}

ArrayList<Token> identificadores():
{
  Token t=null;
  ArrayList<Token> tokens = new ArrayList<Token>();
}
{
  try { 
  	t=< tIDENTIFICADOR >
  		{
  		  if(t!=null){
				tokens.add(t);
  	 		}
  	  	} ( "," t=< tIDENTIFICADOR >
  		{
  		  if(t!=null){
			tokens.add(t);
  	 		}
  	  	} )*
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis en definicion de identificadores incorrecta");
}
{return tokens;}
}

void declaracion_acciones():
{
}
{
  try { 
  	( declaracion_accion() )*
 }catch(ParseException e) {
	error_sintactico(e,"Declaracion de acciones incorrecta");
}
}

void declaracion_accion():
{
  int direccion_anterior=direccion;
}
{
  try {
     
  	cabecera_accion() declaracion_variables() declaracion_acciones() bloque_sentencias()
  	{ tabla_simbolos.eliminar_variables(nivel);
  	  tabla_simbolos.eliminar_parametros(nivel);
  	  direccion=direccion_anterior;
  	  tabla_simbolos.imprimirTabla();
  	  nivel=nivel-1; }
 }catch(ParseException e) {
	error_sintactico(e,"Estructura de accion incorrecta");
}
}

void cabecera_accion():
{
  Token t=null;
}
{
  try { 
  	< tACCION > t=< tIDENTIFICADOR > {  
  		if(t != null){
  		  try {
			tabla_simbolos.introducir_accion(t.image,nivel,direccion);
			direccion = direccion+1;
			tabla_simbolos.imprimirTabla();
			nivel=nivel+1;
  		  } catch(SimboloYaDeclaradoException e) {
			  error_semantico(t.image, t.beginLine, t.beginColumn, e);
  		    }
  	 	}
  	}(parametros_formales())?< tFIN_SENTENCIA >
  	
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis en definicion de accion incorrecta");
}
}

void parametros_formales():
{
}
{
  try { 
  < tPA >(parametros() (< tFIN_SENTENCIA > parametros())*)?< tPC >
}catch(ParseException e) {
	error_sintactico(e,"Estructura de parametros de accion incorrecta");
}
}

void parametros():
{
  ArrayList<Token > tokens=null;
  Tipo_variable tipo=null;
  Clase_parametro clase=null;
}
{
  try { 
  	clase=clase_parametros() tipo=tipo_variables() tokens=identificadores()
  	{
  	  for(int i = 0; i < tokens.size(); i++) {
  	    try { 
		  tabla_simbolos.introducir_parametro(tokens.get(i).image,tipo,clase,nivel,direccion);
		  direccion = direccion+1;
		  tabla_simbolos.imprimirTabla();
		} catch(SimboloYaDeclaradoException e) {
			token = tokens.get(i);
			error_semantico(token.image, token.beginLine, token.beginColumn, e);
		  }	
  	  }
  	}
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de parametros incorrecta");
}
}

Clase_parametro clase_parametros():
{
  Clase_parametro clase=null;
}
{
  try { 
  	< tVAL >{clase=Clase_parametro.VAL; }
  	| < tREF >{clase=Clase_parametro.REF; }
 }catch(ParseException e) {
	error_sintactico(e,"Tipo de parametro no encontrado");
}
{return clase;}
}

void bloque_sentencias():
{
}
{
  try { 
  	< tPRINCIPIO > lista_sentencias() < tFIN >
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de bloque de sentencias incorrecta");
}
}

void lista_sentencias():
{
}
{
  try {
  	(sentencia())*
 }catch(ParseException e) {
	error_sintactico(e,"Estructura de sentencias incorrecta");
}
}

void leer():
{
}
{
  try { 
  	< tLEER > < tPA > identificadores() < tPC >
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de leer incorrecta");
}
}

void escribir():
{
}
{
  try { 
  	< tESCRIBIR > < tPA > lista_escribibles() < tPC >
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de escribir incorrecta");
}
}

void caraent():
{
}
{
  try { 
  < tCARAENT ><tPA >(expresion())<tPC >
}catch(ParseException e) {
	error_sintactico(e,"Sintaxis de caraent incorrecta");
}
}

void entacar():
{
}
{
  try { 
  < tENTACAR ><tPA >(expresion())<tPC >
}catch(ParseException e) {
	error_sintactico(e,"Sintaxis de entacar incorrecta");
}
}

void lista_escribibles():
{
}
{
  try { 
  	( expresion() ) ( < tCOMA > (expresion() ) )*
}catch(ParseException e) {
	error_sintactico(e,"Estructura de escribir incorrecta ");
}
}

void mientras_que():
{
}
{
  try { 
  	< tMQ > expresion() lista_sentencias() < tFMQ >
 }catch(ParseException e) {
	error_sintactico(e,"Estructura de mientras que incorrecta");
}
}

void si():
{
}
{
  try { 
  	< tSI > expresion() < tENT > lista_sentencias() (< tSI_NO > lista_sentencias())* < tFSI >

 }catch(ParseException e) {
	error_sintactico(e,"Estructura de si incorrecta");
}
}

void argumentos():
{
}
{
  try { 
  	< tPA > ( lista_expresiones() )? < tPC >
 }catch(ParseException e) {
	error_sintactico(e,"Estructura de lista de argumentos incorrecta");
}
}

void lista_expresiones():
{
}
{
  try { 
  	expresion()(","expresion())*
 }catch(ParseException e) {
	error_sintactico(e,"Estructura de lista de expresiones incorrecta");
}
}

void seleccion():
{
}
{
  try { 
  	< tPRINCIPIO > < tIDENTIFICADOR > < tLLAVE_IZQ > (sentencia())* < tLLAVE_DCHA >
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de seleccion incorrecta");
}
}

void expresion():
{
}
{
  try {
   expresion2() (operador_relacional() expresion2())*
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de expresion incorrecta");
}
}
void expresion2():
{
}
{
  try {
    (operador_aditivo())? expresion3() ((operador_aditivo()|< tOR >) expresion3())*
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de expresion incorrecta");
}
}

void expresion3():
{
}
{
  try {
   factor()( (operador_multiplicativo()|< tAND >) factor() )*
 }catch(ParseException e) {
	error_sintactico(e,"Sintaxis de expresion incorrecta");
}
}

void operador_relacional():
{
} 
{
  try { 
	 < tMENOR >
	| < tMAYOR >
	| < tMEI >
	| < tMAI >
	| < tIGUAL >
	| < tNI >
}catch(ParseException e) {
	error_sintactico(e,"Operador relacional no encontrado");
}
}

void operador_aditivo():
{
}
{
  try { 
  < tRESTA >
	| < tSUMA >
}catch(ParseException e) {
	error_sintactico(e,"Operador aditivo no encontrado");
}
}

void operador_multiplicativo():
{
} 
{
  try { 
  < tMULL >
	| < tDIV >
	| < tDIV1 >
	| < tMOD >
}catch(ParseException e) {
	error_sintactico(e,"Operador multiplicativo no encontrado");
}
}

void factor():
{
}
{
  try { 
  (< tNOT >)? factor2()
}catch(ParseException e) {
	error_sintactico(e,"Factor no encontrado");
}
}

void factor2():
{
}
{
  try { 
   < tPA > expresion() < tPC >
| < tENTACAR > < tPA > expresion() < tPC >
| < tCARAENT > < tPA > expresion() < tPC >
| < tIDENTIFICADOR >
| < tENTERO >
| < tVALOR_CARACTER >
| < tVALOR_CADENA >
| < tVALOR_CADENA_VACIA >
| < tVALOR_ENTERO >
| < tTRUE >
| < tFALSE >
}catch(ParseException e) {
	error_sintactico(e,"Sintaxis de factor incorrecta");
}
}